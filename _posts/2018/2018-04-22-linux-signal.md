---
layout: post
title: "[Linux][信号] 常见的Linux信号"
date: 2018-04-22
author: mdgsf
comments: true
categories: Linux
tags: [Linux,Signal]
description: ""
published: true #default true
---

# 信号

## 内核处理信号的 3 种方式：

（1）忽略信号。

（2）捕捉信号。

（3）执行系统默认动作。

## 两种不能被忽略的信号

SIGKILL 和 SIGSTOP

## 两种不能被捕捉的信号

SIGKILL 和 SIGSTOP

# 常用信号

## SIGABRT

调用 abort 函数时产生此信号。进程异常终止。

## SIGALRM

当用 alarm 函数设置的定时器超时时，产生此信号。

若由 setitimer(2) 函数设置的间隔时间已经超时时，也产生此信号。

## SIGBUS

当出现某些类型的内存故障时，实现常常产生此种信号。

## SIGCHLD

在一个进程终止或停止时，SIGCHLD 信号被送给其父进程。按系统默认，将忽略此信号。如果父进程希望被告知其子进程的这种状态改变，则应捕捉此信号。信号捕捉函数中通常要调用一种 wait 函数以取得子进程 ID 和其终止状态。

## SIGEMT

指示一个实现定义的硬件故障。

## SIGFPE

此信号表示一个算术运算异常，如除以 0、浮点溢出等。

## SIGHUP

如果终端接口检测到一个连接断开，则将此信号送给与该终端相关的控制进程（会话首进程）。

## SIGILL

此信号表示进程已执行一条非法硬件指令。

## SIGINT

当用户按中断键（一般采用 Delete 和 Ctrl+C）时，终端驱动程序产生此信号并发送至前台进程组中的每一个进程。当一个进程在运行时失控，特别是它正在屏幕上产生大量不需要的输出时，常用此信号终止它。

## SIGIO

此信号指示一个异步 I/O 事件。

## SIGIOT

这指示一个实现定义的硬件故障。

## SIGKILL

这是两个不能被捕捉或忽略信号中的一个。它向系统管理员提供了一种可以杀死任一进程的可靠方法。

## SIGPIPE

如果在管道的读进程已终止时写管道，则产生此信号。

## SIGQUIT

当用户在终端上按退出键（一般采用 Ctrl+\）时，中断驱动程序产生此信号，并发送给前台进程组中的所有进程。此信号不仅终止前台进程组（如 SIGINT 所做的那样），同时产生一个 core 文件。

## SIGSEGV (segmentation violation)

指示进程进行了一次无效的内存引用（通常说明程序有错，比如访问了一个未经初始化的指针）。

## SIGSTOP

这是一个作业控制信号，它停止一个进程。它类似于交互停止信号（SIGTSTP），但是 SIGSTOP 不能被捕捉或忽略。

## SIGSYS

该信号指示一个无效的系统调用。例如：若用户编写了一道使用新系统调用的程序，然后运行该程序的二进制可执行代码，而所用的操作系统却是不支持该系统调用的较早版本，于是就出现该情况。

## SIGTERM

这是由 kill(1) 命令发送的系统默认终止信号。由于该信号是由应用程序捕获的，使用 SIGTERM 也让程序有机会在退出之前做好清理工作，从而优雅地终止（相对于 SIGKILL 而言。SIGKILL 不能被捕捉或忽略）。

## SIGTRAP

指示一个实现定义的硬件故障。

## SIGTSTP

交互停止信号，当用户在终端上按挂起键（一般采用 Ctrl+Z）时，终端驱动程序产生此信号。该信号发送至前台进程组中的所有进程。

## SIGTTIN

当一个后台进程组试图读其控制终端时，终端驱动程序产生此信号。

## SIGTTOU

当一个后台进程组试图读其控制终端时，终端驱动程序产生此信号。

## SIGURG

此信号通知进程已经发生一个紧急情况。在网络连接上接到带外的数据时，可选择地产生此信号。

## SIGUSR1

这是一个用户定义的信号，可用于应用程序。

## SIGUSR2

这是另一个用户定义的信号，与 SIGUSR1 相似，可用于应用程序。

## SIGVTALRM

当一个由 setitimer(2) 函数设置的虚拟间隔时间已经超时时，产生此信号。

## SIGWINCH

如果进程用 ioctl 的设置窗口大小命令更改了窗口大小，则内核将 SIGWINCH 信号发送至前台进程组。

## SIGXFSZ

如果进程超过了其软文件长度限制，则产生此信号。
