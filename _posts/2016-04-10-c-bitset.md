---
layout: post
title:  "[C++] 位操作总结"
date:   2016-04-10
comments: true
categories: c
tags: c, bit
description:
published: true
---

## 原码，反码，补码

```cpp
#include <stdio.h>

int main()
{
    int i = 0;
    printf("i=%d, i=%x\n", i, i); //输出: i=0, i=0

    i = 1;
    printf("i=%d, i=%x\n", i, i); //输出: i=1, i=1

    i = -1;
    printf("i=%d, i=%x\n", i, i); //输出: i=-1, i=ffffffff

    i = 3;
    printf("i=%d, i=%x\n", i, i); //输出: i=3, i=3

    i = -3;
    printf("i=%d, i=%x\n", i, i); //输出: i=-3, i=fffffffd

    return 0;
}
```

**补码**的表示方法是:

1. 正数的补码就是其本身
2. 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

做个mark[原码, 反码, 补码 详解](http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)



## 位操作基础

| 符号     | 描述     | 运算规则                                            |
| ------- | -------- | -------------------------------------------------- |
|  &      |  与      | 两个位都为1时，结果才为1                             |
|  `|`    |  或      | 两个位都为0时，结果才为0                             |
|  ~      |  非      | 0变1，1变0                                          |
|  ^      |  异或    | 相同为0，不同为1                                     |
|  <<     |  左移    | 各二进位全部左移若干位，高位丢弃，低位补0              |
|  >>     |  右移    | 各二进位全部右移若干位，对无符号数，高位补0。有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）           |

注意以下几点：

1. 位操作只能用于**整形数据**，对float和double类型进行位操作会被编译器报错。

2. 对于移位操作，在微软的VC6.0和VS2008编译器都是采取算术称位即算术移位操作，算术移位是相对于逻辑移位，它们在左移操作中都一样，低位补0即可，但在右移中逻辑移位的高位补0而算术移位的高位是补符号位。如下面代码会输出-4和3。

```cpp
#include <stdio.h>
int main()
{
    int a = -15, b = 15;
    printf("%d %d\n", a >> 2, b >> 2);
    return 0;
}
```

因为15=0000 1111(二进制)，右移二位，最高位由符号位填充将得到0000 0011即3。-15 = 1111 0001(二进制)，右移二位，最高位由符号位填充将得到1111 1100即-4。

3. 位操作符的运算优先级比较低，因为尽量使用括号来确保运算顺序，否则很可能会得到莫明其妙的结果。比如要得到像1，3，5，9这些2^i+1的数字。写成int a = 1 << i + 1;是不对的，程序会先执行i + 1，再执行左移操作。应该写成int a = (1 << i) + 1;

```cpp
#include <stdio.h>
int main()
{
    int i = 2;
    printf("%d\n", 1<<i+1);    //输出8
    printf("%d\n", 1<<(i+1));  //输出8
    printf("%d\n", (1<<i)+1);  //输出5
    return 0;
}
```

4. 另外位操作还有一些复合操作符，`如&=、|=、 ^=、<<=、>>=`。

5. 异或：

任何一个数和 0 `异或`都等于它本身，

任何一个数和 -1（即ffffffff） `异或`都相当于取反。

任何两个相等的数 `异或` 都等于 0 。


## 常用位操作小技巧

下面对位操作的一些常见应用作个总结，有判断奇偶、交换两数、变换符号及求绝对值。这些小技巧应用易记，应当熟练掌握。

### 判断奇偶

只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a & 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。

下面程序将输出0到100之间的所有奇数。

```cpp
#include <stdio.h>
int main()
{
    for (int i = 1; i < 100; i++)
        if(i & 1)
            printf("%d ", i);
    printf("\n");
    return 0;
}
```

### 交换两数

[Swap函数实现](http://mdgsf.github.io/ai/2016/04/08/ai-swap.html)

```cpp
void Swap(int &a, int &b)  
{  
    if (a != b)  
    {  
        int c = a;  
        a = b;  
        b = c;  
    }  
}  
```

```cpp
void Swap(int &a, int &b)  
{  
    if (a != b)  
    {  
        a ^= b;  
        b ^= a;  
        a ^= b;  
    }  
}  
```

理解如下：

1. a ^= b   -->   a = a ^ b
2. b ^= a   -->   b = b ^ a = b ^ (a ^ b) = b ^ b ^ a = a
3. a ^= b   -->   a = a ^ b = (a ^ b) ^ a = b


### 变换符号

变换符号就是正数变成负数，负数变成正数。

如对于-11和11，可以通过下面的变换方法将-11变成11

      1111 0101(二进制) –取反-> 0000 1010(二进制) –加1-> 0000 1011(二进制)

同样可以这样的将11变成-11

      0000 1011(二进制) –取反-> 0000 0100(二进制) –加1-> 1111 0101(二进制)

**因此变换符号只需要取反后加1即可**。完整代码如下：

```cpp
#include <stdio.h>

int SignReversal(int i)
{
    return ~i + 1;
}

int main()
{
    int a = 7, b = -123;
    printf("%d %d\n", SignReversal(a), SignReversal(b));  //输出: -7 123
    return 0;
}
```


### 求绝对值

位操作也可以用来求绝对值，对于负数可以通过对其取反后加1来得到正数。对-6可以这样：

      1111 1010(二进制) –取反->0000 0101(二进制) -加1-> 0000 0110(二进制)

来得到6。

因此先移位来取符号位，int i = a >> 31;要注意如果a为正数，i等于0，为负数，i等于-1。然后对i进行判断——如果i等于0，直接返回。否之，返回~a+1。完整代码如下：

```cpp
#include <stdio.h>

int iAbs(int a)
{
    int i = a >> 31;
    return i == 0 ? a : (~a + 1);
}

int main()
{
    int a = 7, b = -123;
    printf("%d %d\n", iAbs(a), iAbs(b));  //输出: 7 123
    return 0;
}
```

现在再分析下。对于任何数，与0异或都会保持不变，与-1即0xFFFFFFFF异或就相当于取反。因此，a与i异或后再减i（因为i为0或-1，所以减i即是要么加0要么加1）也可以得到绝对值。所以可以对上面代码优化下：

```cpp
#include <stdio.h>

int iAbs(int a)
{
    int i = a >> 31;
    return ((a^i) - i);
}

int main()
{
    int a = 7, b = -123;
    printf("%d %d\n", iAbs(a), iAbs(b));
    return 0;
}
```

注意这种方法没用任何判断表达式。



## 位操作与空间压缩

下面考虑下如何在数组中对指定位置置1，先考虑如何对一个整数在指定位置上置1。对于一个整数可以通过将1向左移位后与其相或来达到在指定位上置1的效果，代码如下所示：

```cpp
#include <stdio.h>

int main()
{
    int j = 0;
    j |= 1 << 10;  //给指定的位赋值为 1 。
    printf("%d\n", j);

    if( (j & (1<<10)) != 0 )  //判断指定的位是 1 ， 还是 0 。
    {
        printf("is 1\n");
    }
    else
    {
        printf("is 0\n");
    }
    return 0;
}
```

扩展到数组上，我们可以采用这种方法，因为数组在内存上也是连续分配的一段空间，完全可以“认为”是一个很长的整数。先写一份测试代码，看看如何在数组中使用位操作：

```cpp
#include <stdio.h>

int main()
{
    int i;
    int b[5] = {0};

    for (i = 0; i < 40; i += 3)  //给数组每隔3位赋值为1
    {
        b[i / 32] |= (1 << (i%32));
    }

    for (i = 0; i < 40; i++)  //按位输出数组
    {
        if((b[i / 32] >> (i%32)) & 1)
            putchar('1');
        else
            putchar('0');
    }
    putchar('\n');

    return 0;
}
```

[筛素数法](http://mdgsf.github.io/algorithm/2016/03/11/algorithm-prime.html)

```cpp
#include <stdio.h>

#define N 10000

int main()
{
    int i;
    int j;
    int a[N];

    for (i = 2; i < N; i++) a[i] = 1;

    for (i = 2; i < N; i++)
    {
        if(a[i])
        {
            for (j = i; i*j < N; j++)
                a[i*j] = 0;
        }
    }

    for (i = 2; i < N; i++)
        if(a[i])
            printf("%4d ", i);
    printf("\n");
    return 0;
}
```

将上面筛素数方法改成使用位操作压缩后的筛素数方法：

```cpp
#include <stdio.h>
#include <memory.h>

#define BIT_PER_INT 32
#define N 10000


int g_aiFlag[N / BIT_PER_INT + 1];
int g_aiPrimes[N / 3 + 1];
int g_iIndex;

int main()
{
    g_iIndex = 0;
    memset(g_aiFlag, 0, sizeof(g_aiFlag));

    for (int i = 2; i < N; i++)
    {
        if(! ((g_aiFlag[i/BIT_PER_INT] >> (i%BIT_PER_INT)) & 1) )
        {
            g_aiPrimes[g_iIndex++] = i;
            for (int j = i; j < N; j += i)
                g_aiFlag[j/BIT_PER_INT] |= (1<<(j%BIT_PER_INT));
        }
    }

    for (int k = 0; k < g_iIndex; k++)
        printf("%d ", g_aiPrimes[k]);
    printf("\n");

    return 0;
}
```

另外，还可以使用C++ STL中的bitset类来作素数表。筛素数方法在笔试面试出现的几率还是比较大的，能写出用位操作压缩后的筛素数方法无疑将会使你的代码脱颖而出，因此强烈建议读者自己亲自动手实现一遍，平时多努力，考试才不慌。

位操作的压缩空间技巧也被用于strtok函数的实现，请参考《strtok源码剖析 位操作与空间压缩》（http://blog.csdn.net/morewindows/article/details/8740315）


## 位操作的趣味应用

### 找到孤单的一个数

给一组数字，数组中的数字都是成对出现的，例如有两个1，两个10，两个7，两个8，但是其中有一个数字只出现了一次，要求找出这个数字。

解法一： 弄一个flag数组，flag数组初始化全都置为0， 数字出现第一次就置为1， 数字出现第二次就置为0， 最后遍历flag数组， 唯一是 1 的那个就是只出现一次的数字。

解法二： 将数组中的数字全都一起异或，得到的就是 只出现一次的数字。（空间复杂度为O(1), 时间复杂度为O(n)。）

因为`异或`满足交换律  a ^ b = b ^ a;

```cpp
#include <stdio.h>

int main()
{
    int a[] = {1, 7, 3, 6, 5, 3, 6, 5, 1, 7, 9, 9, 12};
    int iNum = sizeof(a) / sizeof(int);
    printf("%d\n", iNum);

    int iResult = a[0];
    for (int i = 1; i < 13; i++)
        iResult ^= a[i];
    printf("%d\n", iResult);
    return 0;
}
```

### 高低位交换

给出一个16位的无符号整数。称这个二进制数的前8位为“高位”，后8位为“低位”。现在写一程序将它的高低位交换。例如，数34520用二进制表示为：

      10000110 11011000

将它的高低位进行交换，我们得到了一个新的二进制数：

      11011000 10000110

它即是十进制的55430。

这个问题用位操作解决起来非常方便，设x=34520=10000110 11011000(二进制) 由于x为无符号数，右移时会执行逻辑右移即高位补0，

因此x右移8位将得到00000000 10000110。而x左移8位将得到11011000 00000000。

可以发现只要将x>>8与x<<8这两个数相或就可以得到11011000 10000110。

用代码实现非常简洁：

```cpp
#include <stdio.h>

template <class T>
void PrintBinary(T a)
{
    for (int i = sizeof(a) * 8 - 1; i >= 0; i--)
    {
        if((a>>i) & 1)
            putchar('1');
        else
            putchar('0');
        if(i%8 == 0)
            putchar(' ');
    }
    putchar('\n');
}

int main()
{
    unsigned short a = 34520;
    PrintBinary(a);

    a = (a >> 8) | (a << 8);
    PrintBinary(a);
    return 0;
}
```


### 二进制逆序

我们知道如何对字符串求逆序，现在要求计算二进制的逆序，如数34520用二进制表示为：

      10000110 11011000

将它逆序，我们得到了一个新的二进制数：

      00011011 01100001

它即是十进制的7009。

    回顾下字符串的逆序，可以从字符串的首尾开始，依次交换两端的数据。在二进制逆序我们也可以用这种方法，但运用位操作的高低位交换来处理二进制逆序将会得到更简洁的方法。类似于归并排序的分组处理，可以通过下面4步得到16位数据的二进制逆序：

第一步：每2位为一组，组内高低位交换

      10 00 01 10  11 01 10 00

  -->01 00 10 01 11 10 01 00

第二步：每4位为一组，组内高低位交换

      0100 1001 1110 0100

  -->0001 0110 1011 0001

第三步：每8位为一组，组内高低位交换

      00010110 10110001

  -->01100001 00011011

第四步：每16位为一组，组内高低位交换

      01100001 00011011

  -->00011011 01100001

对第一步，可以依次取出每2位作一组，再组内高低位交换，这样有点麻烦，下面介绍一种非常有技巧的方法。先分别取10000110 11011000的奇数位和偶数位，空位以下划线表示。

      原 数    10000110 11011000

      奇数位 1_0_0_1_ 1_0_1_0_

      偶数位  _0_0_1_0 _1_1_0_0

将下划线用0填充，可得

      原 数    10000110 11011000

      奇数位 10000010 10001000

      偶数位 00000100 01010000

再将奇数位右移一位，偶数位左移一位，此时将这两个数据相或即可以达到奇偶位上数据交换的效果了。

      原 数           10000110 11011000

      奇数位右移 01000001 01000100  

      偶数位左移 00001000 10100000

      相或得到      01001001 11100100

可以看出，结果完全达到了奇偶位的数据交换，再来考虑代码的实现——

      取x的奇数位并将偶数位用0填充用代码实现就是x & 0xAAAA

      取x的偶数位并将奇数位用0填充用代码实现就是x & 0x5555

因此，第一步就用代码实现就是：

       x = ((x & 0xAAAA) >> 1) | ((x & 0x5555) << 1);

类似可以得到后三步的代码。完整程序如下：

```cpp
#include <stdio.h>

template <class T>
void PrintBinary(T a)
{
    for (int i = sizeof(a) * 8 - 1; i >= 0; i--)
    {
        if((a>>i) & 1)
            putchar('1');
        else
            putchar('0');
        if(i%8 == 0)
            putchar(' ');
    }
    putchar('\n');
}

int main()
{
    unsigned short a = 34520;
    PrintBinary(a);

    a = ((a & 0xAAAA) >> 1) | ((a & 0x5555) << 1);
    a = ((a & 0xCCCC) >> 2) | ((a & 0x3333) << 2);
    a = ((a & 0xF0F0) >> 4) | ((a & 0x0F0F) << 4);
    a = ((a & 0xFF00) >> 8) | ((a & 0x00FF) << 8);
    PrintBinary(a);
    return 0;
}
```


### 二进制中1的个数

统计二进制中1的个数可以直接移位再判断，当然像《编程之美》书中用循环移位计数或先打一个表再计算都可以。本文详细讲解一种高效的方法。以34520为例，可以通过下面四步来计算其二进制中1的个数二进制中1的个数。

第一步：每2位为一组，组内高低位相加

      10 00 01 10  11 01 10 00

  -->01 00 01 01  10 01 01 00

第二步：每4位为一组，组内高低位相加

      0100 0101 1001 0100

  -->0001 0010 0011 0001

第三步：每8位为一组，组内高低位相加

      00010010 00110001

  -->00000011 00000100

第四步：每16位为一组，组内高低位相加

      00000011 00000100

  -->00000000 00000111

这样最后得到的00000000 00000111即7即34520二进制中1的个数。类似上文中对二进制逆序的做法不难实现第一步的代码：

       x = ((x & 0xAAAA) >> 1) + (x & 0x5555);

好的，有了第一步，后面几步就请读者完成下吧，先动动笔再看下面的完整代码：

```cpp
#include <stdio.h>

template <class T>
void PrintBinary(T a)
{
    for (int i = sizeof(a) * 8 - 1; i >= 0; i--)
    {
        if((a>>i) & 1)
            putchar('1');
        else
            putchar('0');
        if(i%8 == 0)
            putchar(' ');
    }
    putchar('\n');
}

int main()
{
    unsigned short a = 34520;
    PrintBinary(a);

    a = ((a & 0xAAAA) >> 1) + (a & 0x5555);
    a = ((a & 0xCCCC) >> 2) + (a & 0x3333);
    a = ((a & 0xF0F0) >> 4) + (a & 0x0F0F);
    a = ((a & 0xFF00) >> 8) + (a & 0x00FF);
    PrintBinary(a);
    return 0;
}
```




**注1.** int类型一般占4字节，32位。因此15准确表达为

15=00000000 00000000 00000000 00001111(二进制)

-15准确表达为

-15=11111111 11111111 11111111 11110001(二进制)

为了简便起见，文章中使用15=00001111(二进制)，-15=11110001(二进制)。


### 链接

感谢下面的这位兄弟。

[位操作基础篇之位操作全面总结](http://blog.csdn.net/morewindows/article/details/7354571)

[改进的筛素数法](http://blog.csdn.net/morewindows/article/details/7347459)

[数组中只出现1次的两个数字(百度面试题)](http://blog.csdn.net/morewindows/article/details/8214003)
